<!DOCTYPE html>
<html lang="en-us"><head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title>콘크리트 균열 분석 B-COSFIRE(MATLAB) - eunchurn</title>
  <meta name="description" content="콘크리트 균열을 탐지 하는 방법론은 여러가지가 있다. 특히 직접 이미지프로세싱을 통한 직접 추출하는 방식이 일반적이다. 그러나 알고리즘의 수행 능력은 둘째 치더라도 수행 성능은 담보하기 어렵다. B-COSFIRE 필터는 의료 영상에서 혈관을 탐색하는 알고리즘에서 착안한다. 특히 선구조를 식별하는 알고리즘으로써 균열에도 적용이 충분히 가능할꺼라는 시도로 몇몇 엔지니어가 최근 제시하였다.">
  <meta name="generator" content="Jekyll v3.5.2" />
  <!-- OpenGraph meta tags -->
  <meta property="og:title" content="콘크리트 균열 분석 B-COSFIRE(MATLAB)" />
  <meta name="author" content="eunchurn" />
  <meta property="og:locale" content="ko_KR" />
  <meta property="og:description" content="콘크리트 균열을 탐지 하는 방법론은 여러가지가 있다. 특히 직접 이미지프로세싱을 통한 직접 추출하는 방식이 일반적이다. 그러나 알고리즘의 수행 능력은 둘째 치더라도 수행 성능은 담보하기 어렵다. B-COSFIRE 필터는 의료 영상에서 혈관을 탐색하는 알고리즘에서 착안한다. 특히 선구조를 식별하는 알고리즘으로써 균열에도 적용이 충분히 가능할꺼라는 시도로 몇몇 엔지니어가 최근 제시하였다."
  />
  <meta property="og:url" content="http://localhost:4000/engineering/2017/12/30/concrete-cracks-detection-using-b-cosfire-filter/" />
  <meta property="og:site_name" content="콘크리트 균열 분석 B-COSFIRE(MATLAB)" /><meta property="og:type" content="article"><meta property="og:image" content="http://localhost:4000/public/images/2017/12/readme/screenshot.png"><!-- Twitter card meta tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@eunchurn">
  <meta name="twitter:creator" content="@eunchurn" />
  <meta name="twitter:title" content="콘크리트 균열 분석 B-COSFIRE(MATLAB)">
  <meta name="twitter:description" content="콘크리트 균열을 탐지 하는 방법론은 여러가지가 있다. 특히 직접 이미지프로세싱을 통한 직접 추출하는 방식이 일반적이다. 그러나 알고리즘의 수행 능력은 둘째 치더라도 수행 성능은 담보하기 어렵다. B-COSFIRE 필터는 의료 영상에서 혈관을 탐색하는 알고리즘에서 착안한다. 특히 선구조를 식별하는 알고리즘으로써 균열에도 적용이 충분히 가능할꺼라는 시도로 몇몇 엔지니어가 최근 제시하였다."><meta name="twitter:image" content="http://localhost:4000/public/images/2017/12/readme/screenshot.png"><script type="application/ld+json">
      {"name":"eunchurn","description":"all of works archive of Eunchurn Park - works diary, music, saram12saram, remixes, reworks, runway project, production note, magazzine press, interview archive, programming, engineering, web application, development and engineering research archive","author":{"@type":"Person","name":"eunchurn"},"@type":"WebSite","url":"https://eunchurn.com//","headline":"Home","@context":"https://schema.org"}</script>
  <link rel="canonical" href="http://localhost:4000/engineering/2017/12/30/concrete-cracks-detection-using-b-cosfire-filter/">
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/moonspam/NanumSquare/master/nanumsquare.css">
  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/public/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/public/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/public/favicon-16x16.png">
  <link rel="manifest" href="/public/manifest.json">
  <link rel="mask-icon" href="/public/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <meta name="msapplication-config" content="/public/browserconfig.xml">
  <meta name="theme-color" content="#ebebeb">
  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <!-- S12S PLAYER -->
  <link rel="stylesheet" type="text/css" href="/player/css/style.css" />
  <link rel="stylesheet" href="/player/css/sc-player-minimal.css" type="text/css">
  <script type="text/javascript" src="/player/js/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/player/js/jQueryRotate.js"></script>
  <script type="text/javascript" src="/player/js/soundcloud.player.api.js"></script>
  <script type="text/javascript" src="/player/js/sc-player2.js"></script>
  <!-- MATHJAX -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
</head>
<body class="layout-reverse"><!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/"><div class="sidebar-item">
      <p><center>eunchurn works archive<br> <img src="/public/eclogo.png" width=80 alt="logo" /></center></p>
    </div></a><a class="sidebar-nav-item" href="/about/">about</a><a class="sidebar-nav-item" href="/engineering/">engineering</a><a class="sidebar-nav-item" href="/production/">music production</a><a class="sidebar-nav-item" href="/runway/">runway music</a><a class="sidebar-nav-item" href="https://saram12saram.kr">SARAM12SARAM</a>
    <a class="sidebar-nav-item" href="https://github.com/eunchurn">GitHub project</a>
  </nav>
  <div class="sidebar-item">
    <p>
      &copy; 2018. eunchurn. All rights reserved.
    </p>
  </div>
</div>

<div class="wrap">
      <div class="masthead">
        <div class="container">
          <h1 class="masthead-title">
            <a href="/" title="Home"><img src="/public/images/eunchurnlogo.png" width="200" alt="eunchurn"></a>
            <small></small>
          </h1>
        </div>
      </div>
      <div class="container content">
        <div class="post">
  <h1 class="post-title">콘크리트 균열 분석 B-COSFIRE(MATLAB)</h1>
  <span class="post-date">30 Dec 2017</span>
  <p>콘크리트 균열을 탐지 하는 방법론은 여러가지가 있다. 특히 직접 이미지프로세싱을 통한 직접 추출하는 방식이 일반적이다. 그러나 알고리즘의 수행 능력은 둘째 치더라도 수행 성능은 담보하기 어렵다. B-COSFIRE 필터는 의료 영상에서 혈관을 탐색하는 알고리즘에서 착안한다. 특히 선구조를 식별하는 알고리즘으로써 균열에도 적용이 충분히 가능할꺼라는 시도로 몇몇 엔지니어가 최근 제시하였다. 이 연구자는 MATLAB 소스파일을 공개하였다. <a href="https://kr.mathworks.com/matlabcentral/fileexchange/49172-trainable-cosfire-filters-for-curvilinear-structure-delineation-in-images?requestedDomain=true">Trainable COSFIRE filters for curvilinear structure delineation in images</a> 또한 <a href="https://gitlab.com/nicstrisc/B-COSFIRE-MATLAB">Gitlab Repository</a> 에도 계속 업데이트 하고 있다. 자세하게 서술된 학술지 저널까지 공개되어 있다. <a href="http://www.cs.rug.nl/~george/articles/MEDIA2015.pdf">Azzopardi, G., Strisciuglio, N., Vento, M., Petkov, N.: Trainable COSFIRE  filters for vessel delineation with application to retinal images. Medical Image Analysis 19(1), 46 - 57, 2015</a> 예제는 3가지로 소개되어 있다.</p>

<ul>
  <li><code class="highlighter-rouge">ExampleBloodVesselSegmentation.m</code> : 라인 검출기와 라인-엣지 검출기의 구성 및 망막 이미지에서의 혈관 분할에 대한 예제 코드.
최종 응답은 두 필터의 응답 합계로 응용한다.</li>
  <li><code class="highlighter-rouge">PavementCrackDelineation.m</code> (CAIP 2017) : CAIP17에서 제시된 도로 포장 이미지의 균열 감지를 위한 이미지 프로세싱 파이프 라인에 B-COSFIRE 필터 적용. 이 코드는 논문에서 보고 된 벤치 마크 결과를 제공한다.
<em>Azzopardi, G. Petkov, N. “Detection of Curved Lines with B-COSFIRE Filters: A Case Study on Crack Delineation”, IWOBI 2017</em></li>
  <li><code class="highlighter-rouge">INRIAImages.m</code> (IWOBI 2017) : B-COSFIRE 필터를 사용하여 이미지의 가늘고 긴 선형구조를 감지한다.
이 코드는 종이에 사용 된 INRIA 데이터의 이미지에 대한 벤치 마크 결과를 제공한다</li>
</ul>

<p>저자는 소스를 공개하며 다음과 같이 소개하였다.</p>

<blockquote>
  <p>B-COSFIRE filters are non-linear trainable filters for detection of elongated patterns in images.
This is the code of the trainable non-linear B-COSFIRE filters for delineation of elongated patterns in images.</p>
</blockquote>

<p>하지만 학습이라기 보다는 파라미터 최적화를 통해 특정 도로에 적합하도록 개선하는 정도이다. 또한 미세균열을 찾기 위한 작업에서 고해상도 이미지를 한번에 처리하기엔 성능면에서 큰 효과를 거두지 못할 것 같다.</p>

<p>그러나 추후 딥러닝을 위한 ground truth 자료를 충분히 확보하기 위해 본 알고리즘을 써보는 것은 나쁘지 않을 것 같다. 딥러닝에서는 실측자료를 얼마나 많이 얻었냐에 따라 그 성능이 많이 달라지기 때문에 GT작업이 매우 중요하다. 모두 사람의 노동력을 빌릴 수 없기 때문에 최초로 걸러내는 작업에서 B-COSFIRE 알고리즘을 사용하는 방법은 나쁘지 않을 것 같다. 따라서 GT작업을 위한 프로그램을 개발해보았다. MATLAB이지만 MATLAB이 없어도 GUI로 빌드하여 MCR(MATLAB Runtime Compiler)를 통해 배포가 가능하다.</p>

<p>개발자의 논문에 서술된 B-COSFIRE 방법론에 대하여 간략히 소개하고 프로그램 사용법을 기술하였다. 근무하던 회사와 연관되어 있어 소스는 공개가 불가능하다. 하지만 위의 <a href="https://gitlab.com/nicstrisc/B-COSFIRE-MATLAB">Gitlab Repository</a>에서 응용하여 관심있는 사람이라면 쉽게 개발이 가능할 것이다.</p>

<h2 id="b-cosfire-방법론">B-COSFIRE 방법론</h2>
<p>논문에서는 다른 균열 분석 알고리즘과 벤치마크를 수행하였다. 그러나 앞서 이야기한 것처럼 딥러닝을 위한 중간과정으로 채택하였기 때문에 알고리즘의 워크플로는 다음과 같다.</p>

<ol>
  <li>B-COSFIRE filtering</li>
  <li>binarization with nonmaximum suppression</li>
  <li>hysteresis thresholding (최적화 및 벤치마크를 위함)</li>
  <li>minimum enclosing rectangle</li>
  <li>making ground truth</li>
</ol>

<h3 id="configure-of-a-b-cosfire-filter">Configure of a B-COSFIRE filter</h3>
<p>B-COSFIRE 필터는 Gaussian 함수의 그룹 $DoG_{\sigma}$로부터 입력을 받으며 외부 Gaussian 함수는 표준 편차 $\sigma $를 가진다.</p>

<p>\begin{equation}
DoG_{\sigma}(x,y)= \frac{\textrm{exp}\left( -\frac{x^2 + y^2}{2(0.5\sigma)^2}\right)}{2\pi\left(0.5\sigma\right)^2} - \frac{\textrm{exp}\left( -\frac{x^2 + y^2}{2\sigma^2}\right)}{2\pi\sigma^2}
\end{equation}</p>

<p>Petkov와 Vosser<sup id="fnref:petkov2005modifications"><a href="#fn:petkov2005modifications" class="footnote">1</a></sup>에서, 위의 함수에 대해 0.96 $\sigma$의 반경 또는 1.92 $\sigma$의 너비를 가진 라인에 대해 최대 응답이 추출 되었음이 나타났다. 이 결과를 바탕으로 외부 표준 편차 $\sigma = w/1.92$를 설정한다. 여기서 $w$는 관심있는 선의 너비이다.
<br />
B-COSFIRE 필터의 구조, 즉 우리가 DoG 응답을 고려하는 위치는 주어진 프로토타입 패턴에 대한 자동 구성 프로세스에서 결정된다. 구성에 대한 자세한 내용은 Azzopardi et al.의 논문<sup id="fnref:azzopardi2015trainable"><a href="#fn:azzopardi2015trainable" class="footnote">2</a></sup>을 참조바람. 우리는 너비 $w$, 길이 $l$ 및 방향 $\phi$의 프로토타입 선 구조에 B-COSFIRE 필터를 구성한다. 구성 결과는 다음과 같이 설정된다. $B_{w, l, \phi}$ :</p>

<p>\begin{equation}
B_{w,l,\phi} = \left[ (0,0),(\lambda,\phi),(\lambda, 2\pi-\phi)\right] \cup \left[ (\rho_{i},\phi) \right] \cup \left[ (\rho_{i},2\pi-\phi) \right]
\end{equation}</p>

<p>여기서 $\lambda = \left[ (l-1)/2 \right]$ 와 $\rho_{i} = \eta i$ with $i=1,…,\left[(\lambda-1)/\eta \right] -1$. $\phi$ 은 선의 기본 방향이다. $B_{w,l,\phi}$ 집합에서 두개의 튜플은 B-COSFIRE 필터의 지지점에 대한 위치 (거리 및 극각)를 나타내며 center-on Gaussians (DoG) 필터의 응답을 나타낸다. 파라미터 $\eta \left(\textrm{with } 1\leq \eta \leq \lambda \right)$는 고려 된 DoG 응답 사이의 픽셀 간격을 나타낸다. $\eta=1$일때 우리는 원하는 너비 $w$, 길이 $l$, 그리고 방향 $\phi$, 그리고 $\eta=\left[(l-1)/2\right]$일때 (가능한 최대 값) 결과 필터는 세 개의 튜플로만 구성된다: 중앙에서 DoG 응답을 참조하는 튜플 $ (0,0 $ 및 두 개의 튜플 $\left(\left[(l-1)/2\right],\phi \right)$ 및 $\left(\left[(l-1)/2\right],2\pi-\phi\right)$는 B-COSFIRE 필터의 선택도는 지지체의 양쪽면에서 가장 먼 거리를 가리키는 값이다.
<br /><br /></p>
<h3 id="response-of-a-b-cosfire-filter">Response of a B-COSFIRE filter</h3>

<p>B-COSFIRE 필터 $B_{w,l,\phi}(x,y)$의 응답은 <em>filter-blur-shift-combine</em>의 네 단계로 계산된다.
첫 번째 단계에서는 입력 이미지 $I$를 DoG 커널 $DoG_{\sigma=w/1.92}$로 <em>filter</em>하고 $C$로 결과 이미지를 나타낸다:</p>

<p>\begin{equation}
C(x,y)=\left| \sum_{x’=-3\sigma}^{3\sigma} \sum_{y’=-3\sigma}^{3\sigma} I(x,y)DoG_{\sigma}(x-x’,y-y’)\right|^{+}
\end{equation}</p>

<p>여기서 연산자 $\left|.\right|^{+}$는 반파 정류를 나타내며 최근 정류 선형 유닛 (ReLU)으로 알려져 있다.</p>

<p>인공 신경망의 맥락에서, 정류기는 인수의 양의 부분으로 정의된 활성화 함수이다. $\left|x\right|^{+} = \max(0,x)$ 여기서 $x$는 뉴런에 대한 입력이다. 이 함수는 램프(ramp) 기능으로도 알려져 있으며 전기 공학의 반 파장 정류와 유사하다. 이 활성화 함수는 처음 Hahnloser R. H. et al.에 의해 강한 생물학적 동기와 수학적 정당성을 지닌 저널 Nature지의 2000년 논문<sup id="fnref:hahnlose2000"><a href="#fn:hahnlose2000" class="footnote">3</a></sup>에서 소개되었다.  이 함수는 널리 사용되는 로지스틱 시그모이드(확률론에 의해 영감을 얻은 것; 로지스틱 회귀분석 참조)보다 효과적으로 Convolution 네트워크<sup id="fnref:azzopardi2013trainable"><a href="#fn:azzopardi2013trainable" class="footnote">4</a></sup>에 사용되게 되었다. 또한 <sup id="fnref:azzopardi2015trainable:1"><a href="#fn:azzopardi2015trainable" class="footnote">2</a></sup> 대응안인 쌍곡선 탄젠트(hyperbolic tangent) 보다 실용적이다. 2017년에 들어서 현재 이 정류기는 딥 뉴럴 네트워크에서 가장 널리 알려진 활성화 함수이다. <sup id="fnref:bibiloni2016survey"><a href="#fn:bibiloni2016survey" class="footnote">5</a></sup> <sup id="fnref:chai2013recovering"><a href="#fn:chai2013recovering" class="footnote">6</a></sup></p>

<p>그후 선호하는 위치와 관련하여 약간의 tolerance를 허용하기 위해 가중치가 최대인 비선형 blurring 연산으로 DoG 응답을 <em>blur</em> 처리한다. 가중치는 표준 편차 $\sigma_{i}$’ 가 B-COSFIRE 필터의 지원 센터로부터의 거리가 증가함에 따라 선형적으로 증가하는 가우시안 함수에 의해 주어진다 : $\sigma_{i}$’$=\sigma_{0}$’$+\alpha\rho_{i}$. $\sigma_{0}$’ 와 $\alpha$ 값은 파라미터이며, 프로토타입 형태에서 변형에 대한 tolerance를 정규화한다.</p>

<p>세 번째 단계에서는 벡터 $(\rho_{i}, 2\pi-\phi_{i})$에 의해 $i$번째 <em>blur</em> 처리한 DoG 응답을 <em>shift</em> 변환한다. 이러한 방식으로 모든 관련 DoG 응답은 관련 위치, 즉 관련 B-COSFIRE 필터의 지지점에서 연결된다. $i$ 번째 튜플의 $(x, y)$ 위치에서 <em>blur</em>처리되고 <em>shift</em> 된 DoG 응답 $s_{\rho_{i},\phi_{i}}(x,y)$ 은:</p>

<p>\begin{equation}
s_{\rho_{i},\phi_{i}}(x,y) = \max_{x’,y’} \left[ C(x-x’-\Delta x,y-y’-\Delta y) G_{\sigma’_{i}}(x’,y’)\right]
\end{equation}</p>

<p>여기서 $\Delta x = -\rho_{i}\cos\phi_{i}$ 이고, $\Delta y = -\rho_{i}\sin\phi_{i}$ 이다.
마지막 단계에서 B-COSFIRE필터의 응답 $r_{B_{w,l,\phi}}(x,y)$,의 기하평균은 다음과 같다.</p>

<p>\begin{equation}
r_{B_{w,l,\phi}}(x,y) = \left(\prod_{i=1}^{\left| B_{w,l}\right|} s_{\rho_{i},\phi_{i}}(x,y)\right)^{1/\left|B_{w,l}\right|}
\end{equation}</p>

<p>논문에서 방법론 제시 이후의 작업은 타 알고리즘과 비교하기 위한 벤치마크를 수행하는 결과를 나타낸다. 나는 조금 다른 방식으로 이진화(binarization)을 수행했으며, 균열을 분류하기 위한 MER(Minimum enclosing rectangle)작업을 수행하였다. 이 방법은 직관적인 방법론이라서 이미지 프로세싱에 관심이 있다면, DoG 응답을 가지고 충분히 다른 여러방법으로도 추출해 낼 수 있다.
<br /><br /></p>
<h3 id="binarization">Binarization</h3>
<p>이진화 방법은 1차적으로 <code class="highlighter-rouge">binarize()</code>함수로 수행되며 2차적으로 pixel 연결성을 찾아 쓰레숄딩 한다. 이것은 MATLAB <em>Image Processing Toolbox</em>에 있는 <code class="highlighter-rouge">bwconncomp()</code> 함수를 사용한다. <code class="highlighter-rouge">binarize()</code>함수는 아래와 같다.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">function</span> <span class="p">[</span><span class="n">binarymap</span><span class="p">]</span> <span class="o">=</span> <span class="n">binarize</span><span class="p">(</span><span class="n">rotoutput1</span><span class="p">,</span> <span class="n">highthresh</span><span class="p">)</span>
    <span class="n">orienslist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">:</span><span class="nb">pi</span><span class="p">/</span><span class="mi">12</span><span class="p">:</span><span class="nb">pi</span><span class="o">-</span><span class="nb">pi</span><span class="p">/</span><span class="mi">12</span><span class="p">;</span>
    <span class="p">[</span><span class="n">viewResult</span><span class="p">,</span> <span class="n">oriensMatrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_viewimage</span><span class="p">(</span><span class="n">rotoutput1</span><span class="p">,</span><span class="k">...</span>
       <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">orienslist</span><span class="p">),</span> <span class="n">orienslist</span><span class="p">);</span>
    <span class="n">thinning</span> <span class="o">=</span> <span class="n">calc_thinning</span><span class="p">(</span><span class="n">viewResult</span><span class="p">,</span> <span class="n">oriensMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">binarymap</span> <span class="o">=</span> <span class="n">calc_hysteresis</span><span class="p">(</span><span class="n">thinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="k">...</span>
       <span class="mf">0.5</span><span class="o">*</span><span class="n">highthresh</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">thinning</span><span class="p">(:)),</span> <span class="n">highthresh</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">thinning</span><span class="p">(:)));</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>2차 연결픽셀의 쓰레숄딩하는 방법은 아래와 같다. 연결 픽셀 수 <code class="highlighter-rouge">ccthreshold</code>값을 지정해 주어야 한다.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">cc</span> <span class="o">=</span> <span class="n">bwconncomp</span><span class="p">(</span><span class="n">binImg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">nograin</span><span class="o">=</span><span class="nb">cellfun</span><span class="p">(</span><span class="s1">'length'</span><span class="p">,</span><span class="n">cc</span><span class="o">.</span><span class="n">PixelIdxList</span><span class="p">);</span>
<span class="p">[</span><span class="n">val</span><span class="p">,</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">sort</span><span class="p">(</span><span class="n">nograin</span><span class="p">,</span><span class="s1">'descend'</span><span class="p">);</span>    
<span class="n">ite</span> <span class="o">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">val</span><span class="o">&gt;</span><span class="n">ccthreshold</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">'last'</span><span class="p">);</span> <span class="c1">% thresholding cc</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><br /><br /></p>
<h3 id="minimum-enclosing-rectangle">Minimum Enclosing Rectangle</h3>
<p>MER 알고리즘은 <a href="https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/31126/versions/2/previews/minBoundingBox.m/index.html?access_key="><code class="highlighter-rouge">minBoundingBox()</code></a>을 응용하였다.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="k">function</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">minEnclosingRectangle</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="nb">convhull</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">,:),</span><span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">,:));</span>
<span class="n">CH</span> <span class="o">=</span> <span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="n">E</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">CH</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">T</span> <span class="o">=</span> <span class="nb">atan2</span><span class="p">(</span><span class="n">E</span><span class="p">(</span><span class="mi">2</span><span class="p">,:),</span><span class="n">E</span><span class="p">(</span><span class="mi">1</span><span class="p">,:));</span>
<span class="n">T</span> <span class="o">=</span> <span class="nb">unique</span><span class="p">(</span><span class="nb">mod</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="nb">pi</span><span class="p">/</span><span class="mi">2</span><span class="p">));</span>
<span class="n">R</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span> <span class="nb">reshape</span><span class="p">(</span><span class="nb">repmat</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="nb">length</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="k">...</span>
 <span class="o">+</span> <span class="nb">repmat</span><span class="p">([</span><span class="mi">0</span> <span class="o">-</span><span class="nb">pi</span> <span class="p">;</span> <span class="nb">pi</span> <span class="mi">0</span><span class="p">]/</span><span class="mi">2</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
<span class="n">RCH</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">CH</span><span class="p">;</span>
<span class="n">bsize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">RCH</span><span class="p">,[],</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">RCH</span><span class="p">,[],</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">area</span>  <span class="o">=</span> <span class="nb">prod</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">bsize</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">bsize</span><span class="p">)/</span><span class="mi">2</span><span class="p">));</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="nb">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">area</span><span class="p">);</span>
<span class="n">Rf</span>    <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">i</span><span class="o">+</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">],:);</span>
<span class="n">bound</span> <span class="o">=</span> <span class="n">Rf</span> <span class="o">*</span> <span class="n">CH</span><span class="p">;</span>
<span class="n">bmin</span>  <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bound</span><span class="p">,[],</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bmax</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bound</span><span class="p">,[],</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Rf</span> <span class="o">=</span> <span class="n">Rf</span><span class="o">'</span><span class="p">;</span>
<span class="n">bb</span><span class="p">(:,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">bmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">bmin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bb</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">bmin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">bmin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bb</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">bmin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">bmax</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bb</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">bmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">bmax</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Rf</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><br /><br /></p>
<h2 id="프로그램-ui">프로그램 UI</h2>
<p><img src="/public/images/2017/12/readme/screenshot.png" alt="screnshot" />
<br /><br /></p>
<h3 id="usages">Usages</h3>
<ul>
  <li>실행화면
<img src="/public/images/2017/12/readme/intro.png" alt="intro" /></li>
  <li>Image File Open : 이미지 열기 Open 버튼을 클릭하면 다음과 같은 파일탐색창이 나온다. 균열 이미지 파일을 선택한 후 열기를 선택한다.</li>
  <li>이미지 로딩 : 아래 그림과 같이 이미지 파일을 불러온다.
<img src="/public/images/2017/12/readme/loadimage.png" alt="load image" /></li>
  <li>파라미터 설정 : 논문을 참고하여 DoG (Difference of Gaussian)의 파라미터와, 이진화 임계값(threshold)과 픽셀 연결 임계값을 설정한다. 기본설정은 아래표와 같다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">sigma</th>
      <th style="text-align: center">length</th>
      <th style="text-align: center">sigma_0</th>
      <th style="text-align: center">alpha</th>
      <th style="text-align: center">no. of orientation</th>
      <th style="text-align: center">padding size</th>
      <th style="text-align: center">DoG threshold</th>
      <th style="text-align: center">Connected pixels threshold</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3.3</td>
      <td style="text-align: center">14</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">0.5</td>
      <td style="text-align: center">200</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>분석 시작 : Start Analysis 를 클릭하여 분석을 수행한다. (화면 하단에서 분석 진행상황이 표시 된다.)</li>
  <li>분석 완료 : 분석이 완료되면 이미지의 왼쪽은 DoG 응답 결과와 오른쪽 균열 분석결과가 표시 된다. 그리고 이미지의 아래쪽엔 균열 분석한 결과가 스프에드시트 형태로 표시된다.</li>
  <li>zoom tool <img src="/public/images/2017/12/readme/zoomtool.png" alt="" /> 을 이용하여 분석결과를 zoom-in zoom-out하여 결과를 확인할 수 있다. (확대툴을 사용하여 마우스를 이미지위에서 드래그하면, 관심 영역이 확대 됨, 마우스를 더블클릭하면 zoom out 됨)
 <img src="/public/images/2017/12/readme/zoomed.png" alt="zoomed crack" /></li>
  <li>좌측이미지 상단의 Radio버튼에서 original 과 DoG response를 선택하여 원본이미지와 DoG 응답결과를 함께 확인 할 수 있다. (단, 이미지 변경 후 마우스 더블클릭으로 zoom out이 되지 않으니 zoom reset 버튼을 사용)</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">original image</th>
      <th style="text-align: center">DoG response image</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/zoomed.png" alt="original" /></td>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/zoomed_dog.png" alt="DoG response" /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>균열 Result 테이블은 행방향으로 순서대로 검출된 균열의 크기가 큰 균열부터 정렬이 되어있다. 첫번째 열부터
<img src="/public/images/2017/12/readme/result.png" alt="cracks result" />
    <ol>
      <li>균열의 orientation : 진행방향을 기준으로 가로방향에서 균열의 방향을 각도(degree)로 표현한다.</li>
      <li>균열 위치 X : MER(Minimum Enclosing Rectangle)결과에서 균열의 중심좌표의 X축 좌표를 표시한다. (현재는 pixel 단위)</li>
      <li>균열 위치 Y : MER(Minimum Enclosing Rectangle)결과에서 균열의 중심좌표의 Y축 좌표를 표시한다. (현재는 pixel 단위)</li>
      <li>균열 길이 : MER(Minimum Enclosing Rectangle)결과에서 균열의 가장 긴변 축의 길이를 표시한다. (현재는 pixel 단위)</li>
      <li>균열 폭 : Thinning 결과와 이진화 결과를 비교하여 평균 균열 폭을 표시한다. (현재는 pixel 단위)</li>
      <li>실측 균열 : 이 균열이 육안으로 확인했을 때 실제로 균열으로 판단될 때 체크 (ground truth)</li>
      <li>실측 구조물 : 이 균열이 육안으로 확인했을 때 도상의 구조물을 판단될 때 체크 (ground truth)</li>
      <li>실측 노이즈 : 이 균열이 육안으로 확인했을 때 노이즈로 판단될 때 체크 (ground truth)</li>
    </ol>
  </li>
  <li>균열 검측 결과는 마우스로 셀을 선택할 때 마다 균열만 zoom in 해서 보여준다. 이를 해제 하기 위한 방법은 zoom reset 버튼을 클릭하면 전체 이미지 화면을 볼 수 있다. 차례대로 균열을 ground truth로 선택하며 실측과정을 수행한다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/public/images/2017/12/readme/crack01.png" alt="crack 1" /></th>
      <th style="text-align: center"><img src="/public/images/2017/12/readme/crack02.png" alt="crack 2" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack03.png" alt="crack 3" /></td>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack04.png" alt="crack 4" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack05.png" alt="crack 5" /></td>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack06.png" alt="crack 6" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack07.png" alt="crack 7" /></td>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/crack08.png" alt="crack 8" /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>결과 저장 : 균열의 ground truth 결과는 csv(comma separated value)파일로 저장할 수 있다. 또한 DoG 응답 결과와 ground truth에서 균열만 탐색한 결과를 이미지 파일로 저장할 수 있다.
<br /><br />
    <h3 id="ground-truth-result-example">Ground Truth Result (example)</h3>
  </li>
  <li>테스트 이미지로 분석한 콘크리트 균열의 실측자료</li>
  <li>Ground truth (binary image 결과) : 추후 CNN을 위한 실측자료로 활용</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Original Image</th>
      <th style="text-align: center">Ground Truth (Cracks)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/original.png" alt="original" /></td>
      <td style="text-align: center"><img src="/public/images/2017/12/readme/ground_truth_cracks.png" alt="ground truth" /></td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>
<h3 id="version-history">Version History</h3>
<ul>
  <li><strong>v1.0</strong> 한 개의 이미지를 분석함</li>
  <li><strong>v1.0.1</strong> Parameter 오류 수정</li>
  <li><strong>v1.0.1</strong> 균열 결과 default로 노이즈 선택 (효율적인 ground truth를 위함)
<br /><br />
    <h3 id="추후-개발-사항">추후 개발 사항</h3>
  </li>
  <li>[ ] 배치 프로세스 : ground truth 하기전에 분석시간이 조금 걸리기 때문에 배치 분석을 하고 결과 파일을 로딩하여 GT를 수행할 수 있도록 개선 필요</li>
  <li>[ ] GT결과를 바탕으로 crack, structure, noise를 blob을 다른 색상으로 표시할 수 있도록 개선</li>
  <li>[ ] 분석결과 서버 DB에 결과를 저장할 수 있도록 개선</li>
  <li>[ ] 다양한 UI 개선 등
<br /><br /></li>
</ul>

<h3 id="references">References</h3>

<ol class="bibliography"></ol>
<div class="footnotes">
  <ol>
    <li id="fn:petkov2005modifications">
      <p><span id="petkov2005modifications">Petkov, N., &amp; Visser, W. T. (2005). Modifications of center-surround, spot detection and dot-pattern selective operators. <i>Institute of Mathematics and Computing Science, University of Groningen, The Netherlands (CS 2005-9-01)</i>, 1–4.</span>&nbsp;<a href="#fnref:petkov2005modifications" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:azzopardi2015trainable">
      <p><span id="azzopardi2015trainable">Azzopardi, G., Strisciuglio, N., Vento, M., &amp; Petkov, N. (2015). Trainable COSFIRE filters for vessel delineation with application to retinal images. <i>Medical Image Analysis</i>, <i>19</i>(1), 46–57.</span>&nbsp;<a href="#fnref:azzopardi2015trainable" class="reversefootnote">&#8617;</a>&nbsp;<a href="#fnref:azzopardi2015trainable:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:hahnlose2000">
      <p><span id="hahnloser2000digital">Hahnloser, R. H. R., Sarpeshkar, R., Mahowald, M. A., Douglas, R. J., &amp; Seung, H. S. (2000). Digital selection and analogue amplification coexist in a cortex-inspired silicon circuit. <i>Nature</i>, <i>405</i>(6789), 947–951.</span>&nbsp;<a href="#fnref:hahnlose2000" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:azzopardi2013trainable">
      <p><span id="azzopardi2013trainable">Azzopardi, G., &amp; Azzopardi, N. (2013). Trainable COSFIRE filters for keypoint detection and pattern recognition. <i>IEEE Transactions on Pattern Analysis and Machine Intelligence</i>, <i>35</i>(2), 490–503.</span>&nbsp;<a href="#fnref:azzopardi2013trainable" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:bibiloni2016survey">
      <p><span id="bibiloni2016survey">Bibiloni, P., González-Hidalgo, M., &amp; Massanet, S. (2016). A survey on curvilinear object segmentation in multiple applications. <i>Pattern Recognition</i>, <i>60</i>, 949–970.</span>&nbsp;<a href="#fnref:bibiloni2016survey" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:chai2013recovering">
      <p><span id="chai2013recovering">Chai, D., Forstner, W., &amp; Lafarge, F. (2013). Recovering line-networks in images by junction-point processes. In <i>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</i> (pp. 1894–1901).</span>&nbsp;<a href="#fnref:chai2013recovering" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>
<div class="share-page">
  Share this on &rarr;
  <a href="https://twitter.com/intent/tweet?text=콘크리트 균열 분석 B-COSFIRE(MATLAB)&url=/engineering/2017/12/30/concrete-cracks-detection-using-b-cosfire-filter/&via=eunchurn&related=eunchurn"
    rel="nofollow" target="_blank" title="Share on Twitter">Twitter</a>
  <a href="https://facebook.com/sharer.php?u=/engineering/2017/12/30/concrete-cracks-detection-using-b-cosfire-filter/" rel="nofollow" target="_blank" title="Share on Facebook">Facebook</a>
  <a href="https://plus.google.com/share?url=/engineering/2017/12/30/concrete-cracks-detection-using-b-cosfire-filter/" rel="nofollow" target="_blank" title="Share on Google+">Google+</a>
</div>
<div id="disqus_thread"></div>

<div class="related">
  <h2>Recent Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/engineering/2018/01/20/signal-decomposition-hmbsvd/">
            헹켈행렬(Hankel matrix) 기반 신호분리 이론 고찰-1
            <small>20 Jan 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/production/2018/01/17/38pf-interrogator/">
            오래된 DEMO곡
            <small>17 Jan 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/runway/2016/03/24/velvet-underground-x-eunchurn-pale-blue-eyes-heich-es-heich-aw-2016-2017/">
            _Pale Blue Eyes (2016-2017 AW)
            <small>24 Mar 2016</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>
<script>

  (function () { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//eunchurn.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

      </div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');
        document.addEventListener('click', function(e) {
          var target = e.target;
          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;
          checkbox.checked = false;
        }, false);
      })(document);
    </script><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112690812-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112690812-1');
</script></body>
</html>
